<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">


<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="前端," />










<meta name="description" content="es6es6简介ES6既是一个历史名词，也是一个泛指，含义是5.1版以后的JavaScript的下一代标准，涵盖了ES2015、ES2016、ES2017等等，而ES2015则是正式名称，特指该年发布的正式版本的语言标准。本书中提到ES6的地方，一般是指ES2015标准，但有时也是泛指“下一代JavaScript语言”。ES6在ES5的基础上增加了许多新功能和新用法，现在js更加倾向于面向对象的语">
<meta name="keywords" content="前端">
<meta property="og:type" content="article">
<meta property="og:title" content="es6">
<meta property="og:url" content="http://yoursite.com/2017/11/05/es6/index.html">
<meta property="og:site_name" content="隔壁老陳的博客">
<meta property="og:description" content="es6es6简介ES6既是一个历史名词，也是一个泛指，含义是5.1版以后的JavaScript的下一代标准，涵盖了ES2015、ES2016、ES2017等等，而ES2015则是正式名称，特指该年发布的正式版本的语言标准。本书中提到ES6的地方，一般是指ES2015标准，但有时也是泛指“下一代JavaScript语言”。ES6在ES5的基础上增加了许多新功能和新用法，现在js更加倾向于面向对象的语">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-12-04T10:24:50.872Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="es6">
<meta name="twitter:description" content="es6es6简介ES6既是一个历史名词，也是一个泛指，含义是5.1版以后的JavaScript的下一代标准，涵盖了ES2015、ES2016、ES2017等等，而ES2015则是正式名称，特指该年发布的正式版本的语言标准。本书中提到ES6的地方，一般是指ES2015标准，但有时也是泛指“下一代JavaScript语言”。ES6在ES5的基础上增加了许多新功能和新用法，现在js更加倾向于面向对象的语">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/11/05/es6/"/>





  <title>es6 | 隔壁老陳的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/chenmingshuang"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">隔壁老陳的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/05/es6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenmingshuang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="隔壁老陳的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">es6</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-05T21:24:39+08:00">
                2017-11-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/es6/" itemprop="url" rel="index">
                    <span itemprop="name">es6</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h2><h3 id="es6简介"><a href="#es6简介" class="headerlink" title="es6简介"></a>es6简介</h3><p>ES6既是一个历史名词，也是一个泛指，含义是5.1版以后的JavaScript的下一代标准，涵盖了ES2015、ES2016、ES2017等等，而ES2015则是正式名称，特指该年发布的正式版本的语言标准。本书中提到ES6的地方，一般是指ES2015标准，但有时也是泛指“下一代JavaScript语言”。<br>ES6在ES5的基础上增加了许多新功能和新用法，现在js更加倾向于面向对象的语言了，而且用过es6的写法可以大大简化代码。不过很遗憾的是只有当前的一些高版本的浏览器才支持ES6，因此我们需要ES6的转码器babel，利用nodejs的npm功能就可以下载。<br><a href="http://es6.ruanyifeng.com/#docs/intro" target="_blank" rel="external">详情参考</a></p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>ES5里，以function来划分作用域，大括号{}却限定不了var的作用域，我们把它叫做函数作用域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a =1;  //全局变量</span><br><span class="line">function b()&#123;</span><br><span class="line">    var c= 2;  局部变量无法访问</span><br><span class="line">&#125;</span><br><span class="line">console.log(c);//c is not defined</span><br></pre></td></tr></table></figure></p>
<p><strong>块级作用域优势</strong><br>1.块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了<br>2.防止变量污染<br>块级作用域的出现，使得es5中的立即执行函数不在有太多的必要了（仅限解决闭包的问题的时候）。<br>虽然es6中允许了函数在作用域块内部声明，但是考虑到环境导致的行为差异太大，应该避免在块级作用域内部声明函数，如果确实需要，应该写生函数表达式，而不是函数声明语句。</p>
<h4 id="let-amp-const"><a href="#let-amp-const" class="headerlink" title="let&amp;const"></a>let&amp;const</h4><p>ES6里增加了let，const, 声明在{}, -&gt; “function,if ,for等” 的变量作用域被限制在块级。（严格模式下 function 变量属于块级作用域）<br>首先先看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    var a = 1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);// 1</span><br></pre></td></tr></table></figure></p>
<p>相比较而言：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    let a =1;</span><br><span class="line"> &#125;</span><br><span class="line"> console.log(a);//a is not defined</span><br></pre></td></tr></table></figure></p>
<h5 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h5><p>正是因为块级作用域的存在，我们在es5中需要用闭包解决的东西，现在可以直接用let来解决了，比如我们经典的点击弹出的问题，以前需要用闭包去解决，现在我们只需要在for循环里面声明i的时候用let命令就可以了。<br><strong>1.let不存在变量提升</strong><br>不会像var那样将变量提升到作用域的顶部，let声明的变量一定要在let声明之后使用，否则会报错。<br><strong>2.不允许重复声明：</strong><br>在同一个作用域之内，let和const都不允许重复声明同一个变量，包括变量和形参的名字相同的情况。<br><strong>3.一旦let在作用域中声明变量 就将统治这个作用域（暂时性死区）</strong><br><strong>4.Let声明变量 声明周期为块级作用域内里面能用外面，外面不能用里面</strong></p>
<h5 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h5><p>1.<strong>const声明一个只读的常量，一旦声明，常量的值就不允许改变了。</strong>（不可以改变的是地址）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;&#125;;</span><br><span class="line">// 为 foo 添加一个属性，可以成功</span><br><span class="line">foo.prop = 123;</span><br><span class="line">foo.prop // 123</span><br><span class="line">// 将 foo 指向另一个对象，就会报错</span><br><span class="line">foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。<br>2.<strong>声明一个常量必须马上初始化</strong><br>const PI;<br>PI = 3.14<br>3.<strong>let 和 const 一样不能重复声明</strong></p>
<h5 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h5><p>ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。</p>
<h5 id="顶层对象的属性-浏览器里面，顶层对象是window"><a href="#顶层对象的属性-浏览器里面，顶层对象是window" class="headerlink" title="顶层对象的属性 (浏览器里面，顶层对象是window)"></a>顶层对象的属性 (浏览器里面，顶层对象是window)</h5><p>var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。<br><strong>Node里面，顶层对象是global，但其他环境都不支持。</strong></p>
<hr>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>es6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，这被称之为解构赋值。</p>
<h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><p>数组的解构赋值一种匹配模式也就是等号两边的模式相同，左边的变量才会被赋予相应的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let [foo,[[bar],baz]] = [1,[[2],3]]; </span><br><span class="line">console.log(foo,bar,baz); ／／1，2，3</span><br><span class="line">let [x,,y] = [1,2,3];</span><br><span class="line">console.log(x,y);//1,3</span><br><span class="line">// ...tail 把后续元素当成数组如果没有后续元素那么就是空数组。</span><br><span class="line">let [head,...tail] = [1,2,3,4,5];</span><br><span class="line">head//1</span><br><span class="line">tail//[2,3,4,5]</span><br><span class="line">let [a,b,...z] = [&apos;a&apos;];</span><br><span class="line">a//&quot;a&quot;</span><br><span class="line">b//undefind</span><br><span class="line">z//[]</span><br></pre></td></tr></table></figure></p>
<p><strong>1.解构失败就是undefined(右面的值少)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var [foo1] = [];</span><br><span class="line">var [bar,foo2] = [1];</span><br><span class="line">console.log(foo1,foo2);//undefined,undefined</span><br></pre></td></tr></table></figure></p>
<p><strong>2.不完全解构(右面的值多)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let [x,y] = [1,2,3];</span><br><span class="line">let [a,[b],d] = [1,[2,3],4];</span><br><span class="line">console.log(x,y);//1,2</span><br><span class="line">console.log(a,b,d);//1,2,4</span><br></pre></td></tr></table></figure></p>
<p><strong>3.如下情况会报错 右边不是数组（或者严格地说，不是可遍历的结构）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let [foo] = 1;</span><br><span class="line">let [foo] = false;</span><br><span class="line">let [foo] = NaN;</span><br><span class="line">let [foo] = undefined;</span><br><span class="line">let [foo] = null;</span><br><span class="line">let [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="默认赋值"><a href="#默认赋值" class="headerlink" title="默认赋值"></a>默认赋值</h4><p>只有右侧的值严格等于undefined的时候才生效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var [foo = true] = [];</span><br><span class="line">console.log(foo);//true</span><br><span class="line">var [x1, y1 = &apos;b&apos;] = [&apos;a&apos;];</span><br><span class="line">console.log(x1,y1);//&apos;a&apos;,&apos;b&apos;</span><br><span class="line">var [x2, y2 = &apos;b&apos;] = [&apos;a&apos;,undefined];</span><br><span class="line">console.log(x2,y2);//&apos;a&apos;,&apos;b&apos;</span><br><span class="line">//null 不等于undefined 所以不生效</span><br><span class="line">var [x3 = 1] = [null];</span><br><span class="line">console.log(x3);//null</span><br></pre></td></tr></table></figure></p>
<p>默认赋值可以应用解构赋值的其他变量<br>首先看右侧有无和左侧对应的值，没有的话看左侧从左到右解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let [x1 = 1, y1 = x1] = [];</span><br><span class="line">let [x2 = 1, y2 = x2] = [2];</span><br><span class="line">let [x3 = 1, y3 = x3] = [1,2];             </span><br><span class="line">let [x4 = y4, y4 = 1] = [];   --var 和 let 有区别      </span><br><span class="line">console.log(x1,y1);//1,1</span><br><span class="line">console.log(x2,y2);//2,2</span><br><span class="line">console.log(x3,y3);//1,2</span><br><span class="line">console.log(x4,y4);//报错</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="惰性求值-只有在用到的时候，才会求值"><a href="#惰性求值-只有在用到的时候，才会求值" class="headerlink" title="惰性求值 只有在用到的时候，才会求值"></a>惰性求值 只有在用到的时候，才会求值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f () &#123;</span><br><span class="line">       return &apos;aaa&apos;;</span><br><span class="line">      &#125;</span><br><span class="line">   let [x1 = f()] = [1];</span><br><span class="line">   let [x2 = f()] = [];</span><br><span class="line">   console.log(x1);//1</span><br><span class="line">   console.log(x2);//&apos;aaa&apos;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><p>对象的解构赋值是按照属性名称决定的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var &#123;foo,bar&#125; = &#123;foo: &apos;aaa&apos;, bar: &apos;bbb&apos;&#125;;</span><br><span class="line">console.log(foo);//aaa</span><br><span class="line">console.log(bar);//bbb</span><br><span class="line">var &#123;baz&#125; = &#123;foo: &apos;aaa&apos;, bar: &apos;bbb&apos;&#125;;</span><br><span class="line">console.log(baz);//undefined</span><br></pre></td></tr></table></figure></p>
<p>如果变量名称和属性名称不一致 必须写成下面这个样子<br><strong>记住属性名称不是变量 我们可以理解成一种模式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &#123;foo:baz&#125; = &#123;foo: &apos;aaa&apos;&#125;;</span><br><span class="line">//console.log(foo);//undefined</span><br><span class="line">console.log(baz);//aaa</span><br></pre></td></tr></table></figure></p>
<p> <strong>对象赋值注意 应一个已经声明的变量用于解构赋值 必须非常小心</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x;</span><br><span class="line">// js引擎会将&#123;x&#125; 理解成一个代码块，从而发生语法错误。只有不将大括号写在行首可以避免这个问题</span><br><span class="line">//&#123;x&#125; = &#123;x:1&#125;;   不加括号会报错     </span><br><span class="line">(&#123;x&#125; = &#123;x:1&#125;);</span><br><span class="line">console.log(x);//1</span><br></pre></td></tr></table></figure></p>
<p><strong>和数组一样 这种模式匹配的方式 也可以用于嵌套结构</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">            p: [</span><br><span class="line">                &apos;hello&apos;,</span><br><span class="line">                &#123;y: &apos;world&apos;&#125;</span><br><span class="line">            ]</span><br><span class="line">    &#125;;</span><br><span class="line">var &#123;p: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">console.log(x,y);//hello,wrold</span><br></pre></td></tr></table></figure></p>
<p><strong>对象结构也可以自定默认值 默认生效条件和数组一样都是undefined</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var &#123;z = 3&#125; = &#123;&#125;;</span><br><span class="line">console.log(z = 3); //3       </span><br><span class="line">var &#123;x, y = x&#125; = &#123;x:1&#125;;  </span><br><span class="line">console.log(x,y);//1,1</span><br></pre></td></tr></table></figure></p>
<p><strong>字符串的解构赋值  字符串会转化成一个类数组的对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const [a,b,c,d,e] = &apos;hello&apos;;       </span><br><span class="line">console.log(a,b,c,d,e);//h,e,l,l,o</span><br><span class="line">let &#123;length : len&#125; = &apos;hello&apos;;</span><br><span class="line">console.log(len);//5</span><br></pre></td></tr></table></figure></p>
<p>类数组对象有length属性 所以len是5</p>
<hr>
<h4 id="数值和布尔值得解构赋值"><a href="#数值和布尔值得解构赋值" class="headerlink" title="数值和布尔值得解构赋值"></a>数值和布尔值得解构赋值</h4><p><strong>如果等号左边是数值或是布尔值，则会先转为对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let &#123;toString: a&#125; = 123;</span><br><span class="line">let &#123;toString: b&#125; = true;</span><br><span class="line">console.log( a === Number.prototype.toString);//true</span><br><span class="line">console.log( b === Boolean.prototype.toString);//true</span><br><span class="line">// undefined 和 null 不能转成对象所以会出错</span><br><span class="line">//let &#123;toString: x &#125; = undefined;</span><br><span class="line">//let &#123;toString: y &#125; = null</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h4><p>函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被结构成变量 x 和 y<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unction add([x,y]) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">console.log(add([1, 2]));//3</span><br></pre></td></tr></table></figure></p>
<p><strong>函数参数的解构也可以使用默认值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> function move(&#123;x = 0,y = 0&#125; = &#123;&#125;) &#123;</span><br><span class="line">    console.log([x,y]);</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;x:3,y:8&#125;);//[3,8]</span><br><span class="line">move(&#123;x:3&#125;);//[3,0]</span><br><span class="line">move(&#123;&#125;);//[0,0]</span><br><span class="line">move();//[0,0]</span><br><span class="line">function deal(&#123;x,y&#125; = &#123;x: 0 , y: 0&#125;) &#123;</span><br><span class="line">    console.log([x,y]);</span><br><span class="line">&#125;     </span><br><span class="line">deal(&#123;x: 3,y: 8&#125;);//[3,8]</span><br><span class="line">deal(&#123;x: 3&#125;);//[3,undefined]</span><br><span class="line">deal(&#123;&#125;);//[undefined,undefined]</span><br><span class="line">deal();//[0,0]</span><br></pre></td></tr></table></figure></p>
<p>两种默认的写法效果也不一样</p>
<h4 id="解构赋值用途"><a href="#解构赋值用途" class="headerlink" title="解构赋值用途"></a>解构赋值用途</h4><p>1.交换变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">var y = 2;</span><br><span class="line">[x, y] = [y, x];       </span><br><span class="line">console.log(x, y);</span><br></pre></td></tr></table></figure></p>
<p>2.从函数返回多个值<br>3.函数参数的定义<br>4.提交json数据<br>5.函数参数的默认值<br>6.遍历Map解构<br>7.配合requireJS</p>
<hr>
<h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h4><p><strong>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象和可遍历的对象（ES6新增的数据结构 Set和Map）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123;&apos;0&apos;:&apos;a&apos;,&apos;1&apos;:&apos;b&apos;,&apos;2&apos;:&apos;c&apos;,length:3&#125;;   </span><br><span class="line">let arr1 = Array.prototype.slice.call(arrayLike); //es5的方法  </span><br><span class="line">let arr2 = Array.from(arrayLike);／／es6</span><br></pre></td></tr></table></figure></p>
<p><strong>Array.from 还可以接受第二个参数 ，作用类似于数组的map方法 用来对每个元素进行处理然后放入返回的数组之中</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;0:1,1:2,2:3,length:3&#125;;</span><br><span class="line">var arr = Array.from(obj,x =&gt; x*x);</span><br><span class="line">alert(arr); //[1,4,9]</span><br></pre></td></tr></table></figure></p>
<p><strong>Array.from()的另一个应用是，将字符串转化成数组，然后返回字符串的长度。</strong><br>因为它能够正确处理各种Unicode字符，可以避免Javascrit将大于\uFFFF的Unicode字符算成两个字符的bug。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function countSymbols(string) &#123;</span><br><span class="line">  return Array.from(string).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h4><p>Array.of方法用于一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。<strong>（在数组的构造函数中，如果只有一个值，那么这个值被认作为是数组的长度而不是数组的第一个值。）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.of(3, 11, 8) // [3,11,8]</span><br><span class="line">Array.of(3) // [3]</span><br><span class="line">new Array(3)--&gt;数组的长度3</span><br></pre></td></tr></table></figure></p>
<p>Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(Array.of()); //[];</span><br></pre></td></tr></table></figure></p>
<p>Array.of方法可以用下面的代码模拟实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function ArrayOf()&#123;</span><br><span class="line">  return [].slice.call(arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="数组实例的copyWithin"><a href="#数组实例的copyWithin" class="headerlink" title="数组实例的copyWithin()"></a>数组实例的copyWithin()</h4><p><strong>这个方法是在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回该数组。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.copyWithin(target, start = 0, end = this.length)</span><br></pre></td></tr></table></figure></p>
<p>它接受三个参数：<br><strong>target（必选）</strong>：从该位置开始替换数据。<br><strong>start（可选）</strong>：从该位置开始读取数据，默认为0。如果是负值，表示倒数。<br><strong>end（可选）</strong>：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,6,7,8,9];</span><br><span class="line">arr.copyWithin(0,3,6);  </span><br><span class="line">console.log(arr);//(9) [4, 5, 6, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="数组实例的find-和-findIndex"><a href="#数组实例的find-和-findIndex" class="headerlink" title="数组实例的find() 和 findIndex()"></a>数组实例的find() 和 findIndex()</h4><p>数组实例的find方法，用于找到第一个符合条件的数组成员。<font color="red">它的参数是一个回调函数</font>，所有数组成员以此执行该回调函数，直到找出第一个返回值true的成员，然后返回<strong>该成员</strong>。<br><strong>如果没有符合条件的成员，则返回undefined。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> var arr = [1,5,10,15];</span><br><span class="line">     var num = arr.find(function(value,index,arr) &#123;</span><br><span class="line">           return value &gt; 9;</span><br><span class="line">     &#125;);</span><br><span class="line">alert(num); //10（数值）</span><br><span class="line">var arr = arr.findIndex(function (value, index, arr) &#123;</span><br><span class="line">        return value &gt; 9;</span><br><span class="line">     &#125;)</span><br><span class="line">alert(arr);//2  （位置）</span><br></pre></td></tr></table></figure></p>
<p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的<strong>数组成员的位置</strong>，如果所有成员都不符合条件，则返回-1。</p>
<hr>
<h4 id="数组实例的fill"><a href="#数组实例的fill" class="headerlink" title="数组实例的fill()"></a>数组实例的fill()</h4><p><strong>fill方法使用给定值，填充一个数组</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</span><br><span class="line">alert(arr.fill(7));  //[7,7,7]   </span><br><span class="line">alert(new Array(3).fill(7)); //[7,7,7]</span><br><span class="line">//fill方法还可以接受第二个参数和第三个参数，用于指定填充的--起始位置--和--结束位置--。</span><br><span class="line">alert(new Array(8).fill(7,1,2));//[&apos;a&apos;,7,&apos;c&apos;]</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="ES6提供三个新的方法——entries-，keys-和valueOf-——用于遍历数组。"><a href="#ES6提供三个新的方法——entries-，keys-和valueOf-——用于遍历数组。" class="headerlink" title="ES6提供三个新的方法——entries()，keys()和valueOf()——用于遍历数组。"></a>ES6提供三个新的方法——entries()，keys()和valueOf()——用于遍历数组。</h4><p>可以用for…of循环进行遍历，唯一的区别是<br>keys()是对<strong>键名</strong>的遍历<br>values()是对<strong>键值</strong>的遍历<br>entries()是对<strong>键值</strong>对的遍历</p>
<hr>
<h4 id="数组实例的includes"><a href="#数组实例的includes" class="headerlink" title="数组实例的includes()"></a>数组实例的includes()</h4><p><strong>这个方法可以判断数组是否包含给定的值，有则返回true，否则返回false。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3,NaN];</span><br><span class="line">alert(a.includes(2));//true</span><br><span class="line">alert(a.includes(4));//false</span><br><span class="line">alert(a.includes(NaN));//true</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><p><a href="http://es6.ruanyifeng.com/#docs/object" target="_blank" rel="external">属性的简洁表示法&amp;&amp;属性名表达式&amp;&amp;方法的name属性</a></p>
<h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><p><strong>Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致，但是他有两个不同之处：一个是+0不等于-0，一个是NaN等于自身。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//es5</span><br><span class="line">console.log(+0 === -0); //true</span><br><span class="line">console.log(NaN === NaN);//false</span><br><span class="line">//es6    </span><br><span class="line">console.log(Object.is(+0, -0));false</span><br><span class="line">console.log(Object.is(NaN,NaN));true</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign !!!"></a>Object.assign !!!</h4><p><strong>对象合并将源对象的所有可枚举属性，复制到目标对象中 (其实是浅拷贝)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var target = &#123; a: 1 ,b:1&#125;;</span><br><span class="line">var source1 = &#123; b: 2,c:2 &#125;;</span><br><span class="line">var source2 = &#123; c: 3 &#125;;</span><br><span class="line">Object.assign(target, source1, source2);// &#123;a:1, b:2, c:3&#125;</span><br><span class="line">//如果有同名的属性，后面对象的属性会覆盖前面对象的属性。</span><br></pre></td></tr></table></figure></p>
<p>如果只有一个参数，Object.assign会直接返回该参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;a: 1&#125;;</span><br><span class="line">Object.assign(obj) === obj // true</span><br></pre></td></tr></table></figure></p>
<p>如果该参数不是对象，则会先转换成对象，然后返回。<br><strong>由于undefined和null无法转成对象，所以如果他们作为目标对象参数，就会报错。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(undefined) // 报错</span><br><span class="line">Object.assign(null) // 报错</span><br></pre></td></tr></table></figure></p>
<p><strong>Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const source = &#123;</span><br><span class="line">  get foo() &#123; return 1 &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const target = &#123;&#125;;</span><br><span class="line">Object.assign(target, source);// &#123; foo: 1 &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>常见用途</strong>:<br>(1）为对象添加属性<br>(2）为对象添加方法<br>(3）克隆对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function clone(origin) &#123;</span><br><span class="line">  return Object.assign(&#123;&#125;, origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(4）合并多个对象<br>(5）为属性指定默认值</p>
<hr>
<h4 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h4><p>ES6 一共有 5 种方法可以遍历对象的属性。<br> <strong>(1）for…in</strong><br>for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。<br><strong>(2）Object.keys(obj)</strong><br>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。<br><strong>(3)Object.getOwnPropertyNames(obj)</strong><br>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。<br><strong>(4）Object.getOwnPropertySymbols(obj)</strong><br>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。<br><strong>(5）Reflect.ownKeys(obj)</strong><br>Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。<br>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。<br>-首先遍历所有属性名为数值的属性，按照数字排序。<br>-其次遍历所有属性名为字符串的属性，按照生成时间排序。<br>-最后遍历所有属性名为Symbol的属性，按照生成时间排序。</p>
<hr>
<h4 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h4><p>我们知道，<strong>this</strong>关键字总是指向函数所在的<strong>当前对象</strong>，ES6 又新增了另一个类似的关键字<strong>super</strong>，指向<strong>当前对象的原型对象</strong>。</p>
<h4 id="Object-keys-，Object-values-，Object-entries"><a href="#Object-keys-，Object-values-，Object-entries" class="headerlink" title="Object.keys()，Object.values()，Object.entries()"></a>Object.keys()，Object.values()，Object.entries()</h4><p>ES5引入了<strong>Object.keys</strong>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的<strong>键名</strong>。<br><strong>Object.values</strong>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的<strong>键值</strong>。<br><strong>Object.entries</strong>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对<strong>数组</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; foo: &quot;bar&quot;, baz: 42 &#125;;</span><br><span class="line">Object.keys(obj)// [&quot;foo&quot;, &quot;baz&quot;] </span><br><span class="line">var obj = &#123; foo: &quot;bar&quot;, baz: 42 &#125;;</span><br><span class="line">Object.values(obj)// [&quot;bar&quot;, 42]    </span><br><span class="line"> var obj = &#123; foo: &apos;bar&apos;, baz: 42 &#125;;</span><br><span class="line">Object.entries(obj)// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="函数扩展！！！"><a href="#函数扩展！！！" class="headerlink" title="函数扩展！！！"></a>函数扩展！！！</h3><hr>
<h3 id="Set和Map结构"><a href="#Set和Map结构" class="headerlink" title="Set和Map结构"></a>Set和Map结构</h3><h4 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h4><p><strong>Set</strong>：本身是一个构造函数，它类似于数组，但是<strong>set的数据结构重复</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const items = new Set([1, 2, 3, 4, 5, 5, 5, &#123;&#125;,&#123;&#125;]);</span><br><span class="line">var a = new Seta(items);</span><br><span class="line">//Set(7) &#123;1, 2, 3, 4, 5,&#123;&#125;,&#123;&#125;&#125; //set 不能去除相同的引用值</span><br></pre></td></tr></table></figure></p>
<hr>
<h5 id="Set数据结构上的方法"><a href="#Set数据结构上的方法" class="headerlink" title="Set数据结构上的方法"></a>Set数据结构上的方法</h5><p><font color="red">add(value)：</font>添加某个值，返回Set结构本身。</p>
<p><font color="red">delete(value)：</font>删除某个值，返回一个布尔值，表示删除是否成功。</p>
<p><font color="red">has(value)：</font>返回一个布尔值，表示该值是否为Set的成员。</p>
<p><font color="red">clear()：</font>清除所有成员，没有返回值。</p>
<hr>
<h5 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h5><p><font color="red">keys()：</font>返回键名的遍历器</p>
<p><font color="red">values()：</font>返回键值的遍历器</p>
<p><font color="red">entries()：</font>返回键值对的遍历器</p>
<p><font color="red">forEach()：</font>使用回调函数遍历每个成员</p>
<hr>
<h5 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h5><p>WeakSet结构和Set很相似，主要有两个区别：<br>1.WeakSet的成员只能是对象，不能是其他类型的值。<br>2.WeakSet中的对象都是若引用，即垃圾回收机制不会考虑WeakSet对该对象的引用，也就是说，如果有其他对象都不在引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑它是否在WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可以遍历的。</p>
<hr>
<h5 id="Set封装数组去重"><a href="#Set封装数组去重" class="headerlink" title="Set封装数组去重"></a>Set封装数组去重</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function dedupe (arr) &#123; </span><br><span class="line">    return Array.from(new Set(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="Map结构"><a href="#Map结构" class="headerlink" title="Map结构"></a>Map结构</h4><p><strong>Map</strong>：数据结构，可以接受任何类型的值，作为键值它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p>
<p><font color="red">Map主要是解决传统es5中的键值对的键名只能是字符串的问题而引入的一种结构 。在Map中，键值名不限于字符串，可以使各种类型的值。</font></p>
<hr>
<h5 id="Map属性"><a href="#Map属性" class="headerlink" title="Map属性"></a>Map属性</h5><p>(1)<strong>size 属性:</strong>size属性返回 Map 结构的成员总数。<br>(2)<strong>set(key, value):</strong>set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。<br>(3)<strong>get(key):</strong>get方法读取key对应的键值，如果找不到key，返回undefined。<br>(4)<strong>has(key):</strong>has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。<br>(5)<strong>delete(key):</strong>delete方法删除某个键，返回true。如果删除失败，返回false。<br>(6)<strong>clear():</strong>clear方法清除所有成员，没有返回值。</p>
<hr>
<h5 id="Map遍历方法"><a href="#Map遍历方法" class="headerlink" title="Map遍历方法"></a>Map遍历方法</h5><p><strong>Map原生提供三个遍历器生成函数和一个遍历方法。</strong><br>keys()：返回键名的遍历器。<br>values()：返回键值的遍历器。<br>entries()：返回所有成员的遍历器。<br>forEach()：遍历Map的所有成员。<br><strong>WeakMap</strong><br>WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。</p>
<hr>

      
    </div>
    
    
    
    <div>
       
          <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
        
    </div>
    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/前端/" rel="tag"># 前端</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/01/正则/" rel="next" title="正则">
                <i class="fa fa-chevron-left"></i> 正则
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/11/11/gulp/" rel="prev" title="gulp">
                gulp <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/0.jpg"
                alt="chenmingshuang" />
            
              <p class="site-author-name" itemprop="name">chenmingshuang</p>
              <p class="site-description motion-element" itemprop="description">快乐的小二哈</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.ximalaya.com/30018073/album/3740790/" title="陪你读书（JavaScript WEB前端）" target="_blank">陪你读书（JavaScript WEB前端）</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.flyingliu.com" title="师兄的博客(绯椛的博客)" target="_blank">师兄的博客(绯椛的博客)</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.runoob.com/" title="菜鸟教程" target="_blank">菜鸟教程</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#es6"><span class="nav-number">1.</span> <span class="nav-text">es6</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#es6简介"><span class="nav-number">1.1.</span> <span class="nav-text">es6简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#块级作用域"><span class="nav-number">1.2.</span> <span class="nav-text">块级作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#let-amp-const"><span class="nav-number">1.2.1.</span> <span class="nav-text">let&const</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#let命令"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">let命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#const命令"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">const命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ES6-声明变量的六种方法"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">ES6 声明变量的六种方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#顶层对象的属性-浏览器里面，顶层对象是window"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">顶层对象的属性 (浏览器里面，顶层对象是window)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解构赋值"><span class="nav-number">1.3.</span> <span class="nav-text">解构赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组的解构赋值"><span class="nav-number">1.3.1.</span> <span class="nav-text">数组的解构赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#默认赋值"><span class="nav-number">1.3.2.</span> <span class="nav-text">默认赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#惰性求值-只有在用到的时候，才会求值"><span class="nav-number">1.3.3.</span> <span class="nav-text">惰性求值 只有在用到的时候，才会求值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的解构赋值"><span class="nav-number">1.3.4.</span> <span class="nav-text">对象的解构赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数值和布尔值得解构赋值"><span class="nav-number">1.3.5.</span> <span class="nav-text">数值和布尔值得解构赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数参数的解构赋值"><span class="nav-number">1.3.6.</span> <span class="nav-text">函数参数的解构赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解构赋值用途"><span class="nav-number">1.3.7.</span> <span class="nav-text">解构赋值用途</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组扩展"><span class="nav-number">1.4.</span> <span class="nav-text">数组扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-from"><span class="nav-number">1.4.1.</span> <span class="nav-text">Array.from</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-of"><span class="nav-number">1.4.2.</span> <span class="nav-text">Array.of</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组实例的copyWithin"><span class="nav-number">1.4.3.</span> <span class="nav-text">数组实例的copyWithin()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组实例的find-和-findIndex"><span class="nav-number">1.4.4.</span> <span class="nav-text">数组实例的find() 和 findIndex()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组实例的fill"><span class="nav-number">1.4.5.</span> <span class="nav-text">数组实例的fill()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6提供三个新的方法——entries-，keys-和valueOf-——用于遍历数组。"><span class="nav-number">1.4.6.</span> <span class="nav-text">ES6提供三个新的方法——entries()，keys()和valueOf()——用于遍历数组。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组实例的includes"><span class="nav-number">1.4.7.</span> <span class="nav-text">数组实例的includes()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的扩展"><span class="nav-number">1.5.</span> <span class="nav-text">对象的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-is"><span class="nav-number">1.5.1.</span> <span class="nav-text">Object.is()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-assign"><span class="nav-number">1.5.2.</span> <span class="nav-text">Object.assign !!!</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性的遍历"><span class="nav-number">1.5.3.</span> <span class="nav-text">属性的遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#super-关键字"><span class="nav-number">1.5.4.</span> <span class="nav-text">super 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-keys-，Object-values-，Object-entries"><span class="nav-number">1.5.5.</span> <span class="nav-text">Object.keys()，Object.values()，Object.entries()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数扩展！！！"><span class="nav-number">1.6.</span> <span class="nav-text">函数扩展！！！</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set和Map结构"><span class="nav-number">1.7.</span> <span class="nav-text">Set和Map结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Set数据结构"><span class="nav-number">1.7.1.</span> <span class="nav-text">Set数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Set数据结构上的方法"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">Set数据结构上的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#遍历操作"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">遍历操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#WeakSet"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">WeakSet</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Set封装数组去重"><span class="nav-number">1.7.1.4.</span> <span class="nav-text">Set封装数组去重</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map结构"><span class="nav-number">1.7.2.</span> <span class="nav-text">Map结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Map属性"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">Map属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Map遍历方法"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">Map遍历方法</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenmingshuang</span>

  
</div>


  <div class="powered-by"> <a class="theme-link" target="_blank" href="https://hexo.io"></a> 事无善恶 </div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">思想使然 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  









<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  

  

  

</body>
</html>
